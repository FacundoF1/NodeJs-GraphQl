// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  adn: (where?: AdnWhereInput) => Promise<boolean>;
  human: (where?: HumanWhereInput) => Promise<boolean>;
  mutant: (where?: MutantWhereInput) => Promise<boolean>;
  sequence: (where?: SequenceWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  adn: (where: AdnWhereUniqueInput) => AdnNullablePromise;
  adns: (args?: {
    where?: AdnWhereInput;
    orderBy?: AdnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Adn>;
  adnsConnection: (args?: {
    where?: AdnWhereInput;
    orderBy?: AdnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdnConnectionPromise;
  human: (where: HumanWhereUniqueInput) => HumanNullablePromise;
  humans: (args?: {
    where?: HumanWhereInput;
    orderBy?: HumanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Human>;
  humansConnection: (args?: {
    where?: HumanWhereInput;
    orderBy?: HumanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HumanConnectionPromise;
  mutant: (where: MutantWhereUniqueInput) => MutantNullablePromise;
  mutants: (args?: {
    where?: MutantWhereInput;
    orderBy?: MutantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Mutant>;
  mutantsConnection: (args?: {
    where?: MutantWhereInput;
    orderBy?: MutantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MutantConnectionPromise;
  sequence: (where: SequenceWhereUniqueInput) => SequenceNullablePromise;
  sequences: (args?: {
    where?: SequenceWhereInput;
    orderBy?: SequenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sequence>;
  sequencesConnection: (args?: {
    where?: SequenceWhereInput;
    orderBy?: SequenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SequenceConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdn: (data: AdnCreateInput) => AdnPromise;
  updateAdn: (args: {
    data: AdnUpdateInput;
    where: AdnWhereUniqueInput;
  }) => AdnPromise;
  upsertAdn: (args: {
    where: AdnWhereUniqueInput;
    create: AdnCreateInput;
    update: AdnUpdateInput;
  }) => AdnPromise;
  deleteAdn: (where: AdnWhereUniqueInput) => AdnPromise;
  deleteManyAdns: (where?: AdnWhereInput) => BatchPayloadPromise;
  createHuman: (data: HumanCreateInput) => HumanPromise;
  updateHuman: (args: {
    data: HumanUpdateInput;
    where: HumanWhereUniqueInput;
  }) => HumanPromise;
  upsertHuman: (args: {
    where: HumanWhereUniqueInput;
    create: HumanCreateInput;
    update: HumanUpdateInput;
  }) => HumanPromise;
  deleteHuman: (where: HumanWhereUniqueInput) => HumanPromise;
  deleteManyHumans: (where?: HumanWhereInput) => BatchPayloadPromise;
  createMutant: (data: MutantCreateInput) => MutantPromise;
  updateMutant: (args: {
    data: MutantUpdateInput;
    where: MutantWhereUniqueInput;
  }) => MutantPromise;
  upsertMutant: (args: {
    where: MutantWhereUniqueInput;
    create: MutantCreateInput;
    update: MutantUpdateInput;
  }) => MutantPromise;
  deleteMutant: (where: MutantWhereUniqueInput) => MutantPromise;
  deleteManyMutants: (where?: MutantWhereInput) => BatchPayloadPromise;
  createSequence: (data: SequenceCreateInput) => SequencePromise;
  updateSequence: (args: {
    data: SequenceUpdateInput;
    where: SequenceWhereUniqueInput;
  }) => SequencePromise;
  updateManySequences: (args: {
    data: SequenceUpdateManyMutationInput;
    where?: SequenceWhereInput;
  }) => BatchPayloadPromise;
  upsertSequence: (args: {
    where: SequenceWhereUniqueInput;
    create: SequenceCreateInput;
    update: SequenceUpdateInput;
  }) => SequencePromise;
  deleteSequence: (where: SequenceWhereUniqueInput) => SequencePromise;
  deleteManySequences: (where?: SequenceWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  adn: (
    where?: AdnSubscriptionWhereInput
  ) => AdnSubscriptionPayloadSubscription;
  human: (
    where?: HumanSubscriptionWhereInput
  ) => HumanSubscriptionPayloadSubscription;
  mutant: (
    where?: MutantSubscriptionWhereInput
  ) => MutantSubscriptionPayloadSubscription;
  sequence: (
    where?: SequenceSubscriptionWhereInput
  ) => SequenceSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SequenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC";

export type AdnOrderByInput = "id_ASC" | "id_DESC";

export type HumanOrderByInput = "id_ASC" | "id_DESC";

export type MutantOrderByInput = "id_ASC" | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdnWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SequenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  adn?: Maybe<AdnWhereInput>;
  AND?: Maybe<SequenceWhereInput[] | SequenceWhereInput>;
  OR?: Maybe<SequenceWhereInput[] | SequenceWhereInput>;
  NOT?: Maybe<SequenceWhereInput[] | SequenceWhereInput>;
}

export interface AdnWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sequences_every?: Maybe<SequenceWhereInput>;
  sequences_some?: Maybe<SequenceWhereInput>;
  sequences_none?: Maybe<SequenceWhereInput>;
  AND?: Maybe<AdnWhereInput[] | AdnWhereInput>;
  OR?: Maybe<AdnWhereInput[] | AdnWhereInput>;
  NOT?: Maybe<AdnWhereInput[] | AdnWhereInput>;
}

export type HumanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HumanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  postedBy?: Maybe<AdnWhereInput>;
  AND?: Maybe<HumanWhereInput[] | HumanWhereInput>;
  OR?: Maybe<HumanWhereInput[] | HumanWhereInput>;
  NOT?: Maybe<HumanWhereInput[] | HumanWhereInput>;
}

export type MutantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MutantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  postedBy?: Maybe<AdnWhereInput>;
  AND?: Maybe<MutantWhereInput[] | MutantWhereInput>;
  OR?: Maybe<MutantWhereInput[] | MutantWhereInput>;
  NOT?: Maybe<MutantWhereInput[] | MutantWhereInput>;
}

export type SequenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AdnCreateInput {
  id?: Maybe<ID_Input>;
  sequences?: Maybe<SequenceCreateManyWithoutAdnInput>;
}

export interface SequenceCreateManyWithoutAdnInput {
  create?: Maybe<
    SequenceCreateWithoutAdnInput[] | SequenceCreateWithoutAdnInput
  >;
  connect?: Maybe<SequenceWhereUniqueInput[] | SequenceWhereUniqueInput>;
}

export interface SequenceCreateWithoutAdnInput {
  id?: Maybe<ID_Input>;
  value: String;
}

export interface AdnUpdateInput {
  sequences?: Maybe<SequenceUpdateManyWithoutAdnInput>;
}

export interface SequenceUpdateManyWithoutAdnInput {
  create?: Maybe<
    SequenceCreateWithoutAdnInput[] | SequenceCreateWithoutAdnInput
  >;
  delete?: Maybe<SequenceWhereUniqueInput[] | SequenceWhereUniqueInput>;
  connect?: Maybe<SequenceWhereUniqueInput[] | SequenceWhereUniqueInput>;
  set?: Maybe<SequenceWhereUniqueInput[] | SequenceWhereUniqueInput>;
  disconnect?: Maybe<SequenceWhereUniqueInput[] | SequenceWhereUniqueInput>;
  update?: Maybe<
    | SequenceUpdateWithWhereUniqueWithoutAdnInput[]
    | SequenceUpdateWithWhereUniqueWithoutAdnInput
  >;
  upsert?: Maybe<
    | SequenceUpsertWithWhereUniqueWithoutAdnInput[]
    | SequenceUpsertWithWhereUniqueWithoutAdnInput
  >;
  deleteMany?: Maybe<SequenceScalarWhereInput[] | SequenceScalarWhereInput>;
  updateMany?: Maybe<
    | SequenceUpdateManyWithWhereNestedInput[]
    | SequenceUpdateManyWithWhereNestedInput
  >;
}

export interface SequenceUpdateWithWhereUniqueWithoutAdnInput {
  where: SequenceWhereUniqueInput;
  data: SequenceUpdateWithoutAdnDataInput;
}

export interface SequenceUpdateWithoutAdnDataInput {
  value?: Maybe<String>;
}

export interface SequenceUpsertWithWhereUniqueWithoutAdnInput {
  where: SequenceWhereUniqueInput;
  update: SequenceUpdateWithoutAdnDataInput;
  create: SequenceCreateWithoutAdnInput;
}

export interface SequenceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<SequenceScalarWhereInput[] | SequenceScalarWhereInput>;
  OR?: Maybe<SequenceScalarWhereInput[] | SequenceScalarWhereInput>;
  NOT?: Maybe<SequenceScalarWhereInput[] | SequenceScalarWhereInput>;
}

export interface SequenceUpdateManyWithWhereNestedInput {
  where: SequenceScalarWhereInput;
  data: SequenceUpdateManyDataInput;
}

export interface SequenceUpdateManyDataInput {
  value?: Maybe<String>;
}

export interface HumanCreateInput {
  id?: Maybe<ID_Input>;
  postedBy: AdnCreateOneInput;
}

export interface AdnCreateOneInput {
  create?: Maybe<AdnCreateInput>;
  connect?: Maybe<AdnWhereUniqueInput>;
}

export interface HumanUpdateInput {
  postedBy?: Maybe<AdnUpdateOneRequiredInput>;
}

export interface AdnUpdateOneRequiredInput {
  create?: Maybe<AdnCreateInput>;
  update?: Maybe<AdnUpdateDataInput>;
  upsert?: Maybe<AdnUpsertNestedInput>;
  connect?: Maybe<AdnWhereUniqueInput>;
}

export interface AdnUpdateDataInput {
  sequences?: Maybe<SequenceUpdateManyWithoutAdnInput>;
}

export interface AdnUpsertNestedInput {
  update: AdnUpdateDataInput;
  create: AdnCreateInput;
}

export interface MutantCreateInput {
  id?: Maybe<ID_Input>;
  postedBy: AdnCreateOneInput;
}

export interface MutantUpdateInput {
  postedBy?: Maybe<AdnUpdateOneRequiredInput>;
}

export interface SequenceCreateInput {
  id?: Maybe<ID_Input>;
  value: String;
  adn: AdnCreateOneWithoutSequencesInput;
}

export interface AdnCreateOneWithoutSequencesInput {
  create?: Maybe<AdnCreateWithoutSequencesInput>;
  connect?: Maybe<AdnWhereUniqueInput>;
}

export interface AdnCreateWithoutSequencesInput {
  id?: Maybe<ID_Input>;
}

export interface SequenceUpdateInput {
  value?: Maybe<String>;
  adn?: Maybe<AdnUpdateOneRequiredWithoutSequencesInput>;
}

export interface AdnUpdateOneRequiredWithoutSequencesInput {
  create?: Maybe<AdnCreateWithoutSequencesInput>;
  connect?: Maybe<AdnWhereUniqueInput>;
}

export interface SequenceUpdateManyMutationInput {
  value?: Maybe<String>;
}

export interface AdnSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdnWhereInput>;
  AND?: Maybe<AdnSubscriptionWhereInput[] | AdnSubscriptionWhereInput>;
  OR?: Maybe<AdnSubscriptionWhereInput[] | AdnSubscriptionWhereInput>;
  NOT?: Maybe<AdnSubscriptionWhereInput[] | AdnSubscriptionWhereInput>;
}

export interface HumanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HumanWhereInput>;
  AND?: Maybe<HumanSubscriptionWhereInput[] | HumanSubscriptionWhereInput>;
  OR?: Maybe<HumanSubscriptionWhereInput[] | HumanSubscriptionWhereInput>;
  NOT?: Maybe<HumanSubscriptionWhereInput[] | HumanSubscriptionWhereInput>;
}

export interface MutantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MutantWhereInput>;
  AND?: Maybe<MutantSubscriptionWhereInput[] | MutantSubscriptionWhereInput>;
  OR?: Maybe<MutantSubscriptionWhereInput[] | MutantSubscriptionWhereInput>;
  NOT?: Maybe<MutantSubscriptionWhereInput[] | MutantSubscriptionWhereInput>;
}

export interface SequenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SequenceWhereInput>;
  AND?: Maybe<
    SequenceSubscriptionWhereInput[] | SequenceSubscriptionWhereInput
  >;
  OR?: Maybe<SequenceSubscriptionWhereInput[] | SequenceSubscriptionWhereInput>;
  NOT?: Maybe<
    SequenceSubscriptionWhereInput[] | SequenceSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Adn {
  id: ID_Output;
}

export interface AdnPromise extends Promise<Adn>, Fragmentable {
  id: () => Promise<ID_Output>;
  sequences: <T = FragmentableArray<Sequence>>(args?: {
    where?: SequenceWhereInput;
    orderBy?: SequenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AdnSubscription
  extends Promise<AsyncIterator<Adn>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sequences: <T = Promise<AsyncIterator<SequenceSubscription>>>(args?: {
    where?: SequenceWhereInput;
    orderBy?: SequenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AdnNullablePromise extends Promise<Adn | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  sequences: <T = FragmentableArray<Sequence>>(args?: {
    where?: SequenceWhereInput;
    orderBy?: SequenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Sequence {
  id: ID_Output;
  value: String;
}

export interface SequencePromise extends Promise<Sequence>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  adn: <T = AdnPromise>() => T;
}

export interface SequenceSubscription
  extends Promise<AsyncIterator<Sequence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  adn: <T = AdnSubscription>() => T;
}

export interface SequenceNullablePromise
  extends Promise<Sequence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  adn: <T = AdnPromise>() => T;
}

export interface AdnConnection {
  pageInfo: PageInfo;
  edges: AdnEdge[];
}

export interface AdnConnectionPromise
  extends Promise<AdnConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdnEdge>>() => T;
  aggregate: <T = AggregateAdnPromise>() => T;
}

export interface AdnConnectionSubscription
  extends Promise<AsyncIterator<AdnConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdnEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdnSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdnEdge {
  node: Adn;
  cursor: String;
}

export interface AdnEdgePromise extends Promise<AdnEdge>, Fragmentable {
  node: <T = AdnPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdnEdgeSubscription
  extends Promise<AsyncIterator<AdnEdge>>,
    Fragmentable {
  node: <T = AdnSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdn {
  count: Int;
}

export interface AggregateAdnPromise
  extends Promise<AggregateAdn>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdnSubscription
  extends Promise<AsyncIterator<AggregateAdn>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Human {
  id: ID_Output;
}

export interface HumanPromise extends Promise<Human>, Fragmentable {
  id: () => Promise<ID_Output>;
  postedBy: <T = AdnPromise>() => T;
}

export interface HumanSubscription
  extends Promise<AsyncIterator<Human>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  postedBy: <T = AdnSubscription>() => T;
}

export interface HumanNullablePromise
  extends Promise<Human | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  postedBy: <T = AdnPromise>() => T;
}

export interface HumanConnection {
  pageInfo: PageInfo;
  edges: HumanEdge[];
}

export interface HumanConnectionPromise
  extends Promise<HumanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HumanEdge>>() => T;
  aggregate: <T = AggregateHumanPromise>() => T;
}

export interface HumanConnectionSubscription
  extends Promise<AsyncIterator<HumanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HumanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHumanSubscription>() => T;
}

export interface HumanEdge {
  node: Human;
  cursor: String;
}

export interface HumanEdgePromise extends Promise<HumanEdge>, Fragmentable {
  node: <T = HumanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HumanEdgeSubscription
  extends Promise<AsyncIterator<HumanEdge>>,
    Fragmentable {
  node: <T = HumanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHuman {
  count: Int;
}

export interface AggregateHumanPromise
  extends Promise<AggregateHuman>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHumanSubscription
  extends Promise<AsyncIterator<AggregateHuman>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Mutant {
  id: ID_Output;
}

export interface MutantPromise extends Promise<Mutant>, Fragmentable {
  id: () => Promise<ID_Output>;
  postedBy: <T = AdnPromise>() => T;
}

export interface MutantSubscription
  extends Promise<AsyncIterator<Mutant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  postedBy: <T = AdnSubscription>() => T;
}

export interface MutantNullablePromise
  extends Promise<Mutant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  postedBy: <T = AdnPromise>() => T;
}

export interface MutantConnection {
  pageInfo: PageInfo;
  edges: MutantEdge[];
}

export interface MutantConnectionPromise
  extends Promise<MutantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MutantEdge>>() => T;
  aggregate: <T = AggregateMutantPromise>() => T;
}

export interface MutantConnectionSubscription
  extends Promise<AsyncIterator<MutantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MutantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMutantSubscription>() => T;
}

export interface MutantEdge {
  node: Mutant;
  cursor: String;
}

export interface MutantEdgePromise extends Promise<MutantEdge>, Fragmentable {
  node: <T = MutantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MutantEdgeSubscription
  extends Promise<AsyncIterator<MutantEdge>>,
    Fragmentable {
  node: <T = MutantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMutant {
  count: Int;
}

export interface AggregateMutantPromise
  extends Promise<AggregateMutant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMutantSubscription
  extends Promise<AsyncIterator<AggregateMutant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SequenceConnection {
  pageInfo: PageInfo;
  edges: SequenceEdge[];
}

export interface SequenceConnectionPromise
  extends Promise<SequenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SequenceEdge>>() => T;
  aggregate: <T = AggregateSequencePromise>() => T;
}

export interface SequenceConnectionSubscription
  extends Promise<AsyncIterator<SequenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SequenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSequenceSubscription>() => T;
}

export interface SequenceEdge {
  node: Sequence;
  cursor: String;
}

export interface SequenceEdgePromise
  extends Promise<SequenceEdge>,
    Fragmentable {
  node: <T = SequencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SequenceEdgeSubscription
  extends Promise<AsyncIterator<SequenceEdge>>,
    Fragmentable {
  node: <T = SequenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSequence {
  count: Int;
}

export interface AggregateSequencePromise
  extends Promise<AggregateSequence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSequenceSubscription
  extends Promise<AsyncIterator<AggregateSequence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdnSubscriptionPayload {
  mutation: MutationType;
  node: Adn;
  updatedFields: String[];
  previousValues: AdnPreviousValues;
}

export interface AdnSubscriptionPayloadPromise
  extends Promise<AdnSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdnPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdnPreviousValuesPromise>() => T;
}

export interface AdnSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdnSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdnSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdnPreviousValuesSubscription>() => T;
}

export interface AdnPreviousValues {
  id: ID_Output;
}

export interface AdnPreviousValuesPromise
  extends Promise<AdnPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AdnPreviousValuesSubscription
  extends Promise<AsyncIterator<AdnPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface HumanSubscriptionPayload {
  mutation: MutationType;
  node: Human;
  updatedFields: String[];
  previousValues: HumanPreviousValues;
}

export interface HumanSubscriptionPayloadPromise
  extends Promise<HumanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HumanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HumanPreviousValuesPromise>() => T;
}

export interface HumanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HumanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HumanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HumanPreviousValuesSubscription>() => T;
}

export interface HumanPreviousValues {
  id: ID_Output;
}

export interface HumanPreviousValuesPromise
  extends Promise<HumanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HumanPreviousValuesSubscription
  extends Promise<AsyncIterator<HumanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MutantSubscriptionPayload {
  mutation: MutationType;
  node: Mutant;
  updatedFields: String[];
  previousValues: MutantPreviousValues;
}

export interface MutantSubscriptionPayloadPromise
  extends Promise<MutantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MutantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MutantPreviousValuesPromise>() => T;
}

export interface MutantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MutantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MutantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MutantPreviousValuesSubscription>() => T;
}

export interface MutantPreviousValues {
  id: ID_Output;
}

export interface MutantPreviousValuesPromise
  extends Promise<MutantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MutantPreviousValuesSubscription
  extends Promise<AsyncIterator<MutantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SequenceSubscriptionPayload {
  mutation: MutationType;
  node: Sequence;
  updatedFields: String[];
  previousValues: SequencePreviousValues;
}

export interface SequenceSubscriptionPayloadPromise
  extends Promise<SequenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SequencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SequencePreviousValuesPromise>() => T;
}

export interface SequenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SequenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SequenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SequencePreviousValuesSubscription>() => T;
}

export interface SequencePreviousValues {
  id: ID_Output;
  value: String;
}

export interface SequencePreviousValuesPromise
  extends Promise<SequencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
}

export interface SequencePreviousValuesSubscription
  extends Promise<AsyncIterator<SequencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Mutant",
    embedded: false
  },
  {
    name: "Human",
    embedded: false
  },
  {
    name: "Adn",
    embedded: false
  },
  {
    name: "Sequence",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
