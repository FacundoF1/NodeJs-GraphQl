module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Adn {
  id: ID!
  sequences(where: SequenceWhereInput, orderBy: SequenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sequence!]
}

type AdnConnection {
  pageInfo: PageInfo!
  edges: [AdnEdge]!
  aggregate: AggregateAdn!
}

input AdnCreateInput {
  id: ID
  sequences: SequenceCreateManyWithoutAdnInput
}

input AdnCreateOneInput {
  create: AdnCreateInput
  connect: AdnWhereUniqueInput
}

input AdnCreateOneWithoutSequencesInput {
  create: AdnCreateWithoutSequencesInput
  connect: AdnWhereUniqueInput
}

input AdnCreateWithoutSequencesInput {
  id: ID
}

type AdnEdge {
  node: Adn!
  cursor: String!
}

enum AdnOrderByInput {
  id_ASC
  id_DESC
}

type AdnPreviousValues {
  id: ID!
}

type AdnSubscriptionPayload {
  mutation: MutationType!
  node: Adn
  updatedFields: [String!]
  previousValues: AdnPreviousValues
}

input AdnSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdnWhereInput
  AND: [AdnSubscriptionWhereInput!]
  OR: [AdnSubscriptionWhereInput!]
  NOT: [AdnSubscriptionWhereInput!]
}

input AdnUpdateDataInput {
  sequences: SequenceUpdateManyWithoutAdnInput
}

input AdnUpdateInput {
  sequences: SequenceUpdateManyWithoutAdnInput
}

input AdnUpdateOneRequiredInput {
  create: AdnCreateInput
  update: AdnUpdateDataInput
  upsert: AdnUpsertNestedInput
  connect: AdnWhereUniqueInput
}

input AdnUpdateOneRequiredWithoutSequencesInput {
  create: AdnCreateWithoutSequencesInput
  connect: AdnWhereUniqueInput
}

input AdnUpsertNestedInput {
  update: AdnUpdateDataInput!
  create: AdnCreateInput!
}

input AdnWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sequences_every: SequenceWhereInput
  sequences_some: SequenceWhereInput
  sequences_none: SequenceWhereInput
  AND: [AdnWhereInput!]
  OR: [AdnWhereInput!]
  NOT: [AdnWhereInput!]
}

input AdnWhereUniqueInput {
  id: ID
}

type AggregateAdn {
  count: Int!
}

type AggregateHuman {
  count: Int!
}

type AggregateMutant {
  count: Int!
}

type AggregateSequence {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Human {
  id: ID!
  postedBy: Adn!
}

type HumanConnection {
  pageInfo: PageInfo!
  edges: [HumanEdge]!
  aggregate: AggregateHuman!
}

input HumanCreateInput {
  id: ID
  postedBy: AdnCreateOneInput!
}

type HumanEdge {
  node: Human!
  cursor: String!
}

enum HumanOrderByInput {
  id_ASC
  id_DESC
}

type HumanPreviousValues {
  id: ID!
}

type HumanSubscriptionPayload {
  mutation: MutationType!
  node: Human
  updatedFields: [String!]
  previousValues: HumanPreviousValues
}

input HumanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HumanWhereInput
  AND: [HumanSubscriptionWhereInput!]
  OR: [HumanSubscriptionWhereInput!]
  NOT: [HumanSubscriptionWhereInput!]
}

input HumanUpdateInput {
  postedBy: AdnUpdateOneRequiredInput
}

input HumanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  postedBy: AdnWhereInput
  AND: [HumanWhereInput!]
  OR: [HumanWhereInput!]
  NOT: [HumanWhereInput!]
}

input HumanWhereUniqueInput {
  id: ID
}

scalar Long

type Mutant {
  id: ID!
  postedBy: Adn!
}

type MutantConnection {
  pageInfo: PageInfo!
  edges: [MutantEdge]!
  aggregate: AggregateMutant!
}

input MutantCreateInput {
  id: ID
  postedBy: AdnCreateOneInput!
}

type MutantEdge {
  node: Mutant!
  cursor: String!
}

enum MutantOrderByInput {
  id_ASC
  id_DESC
}

type MutantPreviousValues {
  id: ID!
}

type MutantSubscriptionPayload {
  mutation: MutationType!
  node: Mutant
  updatedFields: [String!]
  previousValues: MutantPreviousValues
}

input MutantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MutantWhereInput
  AND: [MutantSubscriptionWhereInput!]
  OR: [MutantSubscriptionWhereInput!]
  NOT: [MutantSubscriptionWhereInput!]
}

input MutantUpdateInput {
  postedBy: AdnUpdateOneRequiredInput
}

input MutantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  postedBy: AdnWhereInput
  AND: [MutantWhereInput!]
  OR: [MutantWhereInput!]
  NOT: [MutantWhereInput!]
}

input MutantWhereUniqueInput {
  id: ID
}

type Mutation {
  createAdn(data: AdnCreateInput!): Adn!
  updateAdn(data: AdnUpdateInput!, where: AdnWhereUniqueInput!): Adn
  upsertAdn(where: AdnWhereUniqueInput!, create: AdnCreateInput!, update: AdnUpdateInput!): Adn!
  deleteAdn(where: AdnWhereUniqueInput!): Adn
  deleteManyAdns(where: AdnWhereInput): BatchPayload!
  createHuman(data: HumanCreateInput!): Human!
  updateHuman(data: HumanUpdateInput!, where: HumanWhereUniqueInput!): Human
  upsertHuman(where: HumanWhereUniqueInput!, create: HumanCreateInput!, update: HumanUpdateInput!): Human!
  deleteHuman(where: HumanWhereUniqueInput!): Human
  deleteManyHumans(where: HumanWhereInput): BatchPayload!
  createMutant(data: MutantCreateInput!): Mutant!
  updateMutant(data: MutantUpdateInput!, where: MutantWhereUniqueInput!): Mutant
  upsertMutant(where: MutantWhereUniqueInput!, create: MutantCreateInput!, update: MutantUpdateInput!): Mutant!
  deleteMutant(where: MutantWhereUniqueInput!): Mutant
  deleteManyMutants(where: MutantWhereInput): BatchPayload!
  createSequence(data: SequenceCreateInput!): Sequence!
  updateSequence(data: SequenceUpdateInput!, where: SequenceWhereUniqueInput!): Sequence
  updateManySequences(data: SequenceUpdateManyMutationInput!, where: SequenceWhereInput): BatchPayload!
  upsertSequence(where: SequenceWhereUniqueInput!, create: SequenceCreateInput!, update: SequenceUpdateInput!): Sequence!
  deleteSequence(where: SequenceWhereUniqueInput!): Sequence
  deleteManySequences(where: SequenceWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  adn(where: AdnWhereUniqueInput!): Adn
  adns(where: AdnWhereInput, orderBy: AdnOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Adn]!
  adnsConnection(where: AdnWhereInput, orderBy: AdnOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdnConnection!
  human(where: HumanWhereUniqueInput!): Human
  humans(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Human]!
  humansConnection(where: HumanWhereInput, orderBy: HumanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HumanConnection!
  mutant(where: MutantWhereUniqueInput!): Mutant
  mutants(where: MutantWhereInput, orderBy: MutantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mutant]!
  mutantsConnection(where: MutantWhereInput, orderBy: MutantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MutantConnection!
  sequence(where: SequenceWhereUniqueInput!): Sequence
  sequences(where: SequenceWhereInput, orderBy: SequenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sequence]!
  sequencesConnection(where: SequenceWhereInput, orderBy: SequenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SequenceConnection!
  node(id: ID!): Node
}

type Sequence {
  id: ID!
  value: String!
  adn: Adn!
}

type SequenceConnection {
  pageInfo: PageInfo!
  edges: [SequenceEdge]!
  aggregate: AggregateSequence!
}

input SequenceCreateInput {
  id: ID
  value: String!
  adn: AdnCreateOneWithoutSequencesInput!
}

input SequenceCreateManyWithoutAdnInput {
  create: [SequenceCreateWithoutAdnInput!]
  connect: [SequenceWhereUniqueInput!]
}

input SequenceCreateWithoutAdnInput {
  id: ID
  value: String!
}

type SequenceEdge {
  node: Sequence!
  cursor: String!
}

enum SequenceOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
}

type SequencePreviousValues {
  id: ID!
  value: String!
}

input SequenceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [SequenceScalarWhereInput!]
  OR: [SequenceScalarWhereInput!]
  NOT: [SequenceScalarWhereInput!]
}

type SequenceSubscriptionPayload {
  mutation: MutationType!
  node: Sequence
  updatedFields: [String!]
  previousValues: SequencePreviousValues
}

input SequenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SequenceWhereInput
  AND: [SequenceSubscriptionWhereInput!]
  OR: [SequenceSubscriptionWhereInput!]
  NOT: [SequenceSubscriptionWhereInput!]
}

input SequenceUpdateInput {
  value: String
  adn: AdnUpdateOneRequiredWithoutSequencesInput
}

input SequenceUpdateManyDataInput {
  value: String
}

input SequenceUpdateManyMutationInput {
  value: String
}

input SequenceUpdateManyWithoutAdnInput {
  create: [SequenceCreateWithoutAdnInput!]
  delete: [SequenceWhereUniqueInput!]
  connect: [SequenceWhereUniqueInput!]
  set: [SequenceWhereUniqueInput!]
  disconnect: [SequenceWhereUniqueInput!]
  update: [SequenceUpdateWithWhereUniqueWithoutAdnInput!]
  upsert: [SequenceUpsertWithWhereUniqueWithoutAdnInput!]
  deleteMany: [SequenceScalarWhereInput!]
  updateMany: [SequenceUpdateManyWithWhereNestedInput!]
}

input SequenceUpdateManyWithWhereNestedInput {
  where: SequenceScalarWhereInput!
  data: SequenceUpdateManyDataInput!
}

input SequenceUpdateWithoutAdnDataInput {
  value: String
}

input SequenceUpdateWithWhereUniqueWithoutAdnInput {
  where: SequenceWhereUniqueInput!
  data: SequenceUpdateWithoutAdnDataInput!
}

input SequenceUpsertWithWhereUniqueWithoutAdnInput {
  where: SequenceWhereUniqueInput!
  update: SequenceUpdateWithoutAdnDataInput!
  create: SequenceCreateWithoutAdnInput!
}

input SequenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  adn: AdnWhereInput
  AND: [SequenceWhereInput!]
  OR: [SequenceWhereInput!]
  NOT: [SequenceWhereInput!]
}

input SequenceWhereUniqueInput {
  id: ID
}

type Subscription {
  adn(where: AdnSubscriptionWhereInput): AdnSubscriptionPayload
  human(where: HumanSubscriptionWhereInput): HumanSubscriptionPayload
  mutant(where: MutantSubscriptionWhereInput): MutantSubscriptionPayload
  sequence(where: SequenceSubscriptionWhereInput): SequenceSubscriptionPayload
}
`
      }
    